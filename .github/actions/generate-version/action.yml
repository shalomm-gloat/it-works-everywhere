name: 'Generate Version'
description: 'Generate semantic version tags based on branch and package.json'

outputs:
  version:
    description: 'Clean version string'
    value: ${{ steps.version.outputs.version }}
  base_version:
    description: 'Base version from package.json'
    value: ${{ steps.version.outputs.base_version }}
  version_suffix:
    description: 'Pre-release suffix'
    value: ${{ steps.version.outputs.version_suffix }}
  env_suffix:
    description: 'Environment identifier'
    value: ${{ steps.version.outputs.env_suffix }}
  version_type:
    description: 'Version classification'
    value: ${{ steps.version.outputs.version_type }}
  commit_sha:
    description: 'Short commit SHA'
    value: ${{ steps.version.outputs.commit_sha }}
  build_date:
    description: 'Build timestamp'
    value: ${{ steps.version.outputs.build_date }}

runs:
  using: 'composite'
  steps:
    - name: Generate version tag
      id: version
      shell: bash
      run: |
        # Get base version from package.json (source of truth)
        BASE_VERSION=$(node -p "require('./package.json').version")
        
        # Branch-based versioning strategy (SemVer 2.0.0 compliant)
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          # Production: Clean version for stability
          VERSION_SUFFIX=""
          ENV_SUFFIX="prod"
          VERSION_TYPE="release"
        elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
          # Development: -dev suffix for integration testing
          VERSION_SUFFIX="-dev"
          ENV_SUFFIX="dev"
          VERSION_TYPE="pre-release"
        elif [ "${{ github.ref }}" = "refs/heads/staging" ]; then
          # Staging: -stg suffix for pre-production validation
          VERSION_SUFFIX="-stg"
          ENV_SUFFIX="stg"
          VERSION_TYPE="pre-release"
        elif [[ "${{ github.ref }}" =~ refs/heads/release/.* ]]; then
          # Release candidates: -rc.X for final testing
          RC_NUMBER=$(echo "${{ github.ref }}" | sed 's|refs/heads/release/||')
          VERSION_SUFFIX="-rc.${RC_NUMBER}"
          ENV_SUFFIX="rc"
          VERSION_TYPE="release-candidate"
        elif [[ "${{ github.ref }}" =~ refs/heads/hotfix/.* ]]; then
          # Hotfixes: -hotfix for emergency fixes
          VERSION_SUFFIX="-hotfix"
          ENV_SUFFIX="hotfix"
          VERSION_TYPE="pre-release"
        else
          # Feature branches: -dev suffix for consistency
          VERSION_SUFFIX="-dev"
          ENV_SUFFIX="dev"
          VERSION_TYPE="pre-release"
        fi
        
        # Build metadata for traceability (not included in Docker tags)
        COMMIT_SHA=$(git rev-parse --short HEAD)
        BUILD_DATE=$(date -u +"%Y%m%d.%H%M%S")
        
        # Create Docker-safe version (no build metadata for compatibility)
        if [ -n "$VERSION_SUFFIX" ]; then
          # Pre-release: v1.0.0-dev
          DOCKER_VERSION="v${BASE_VERSION}${VERSION_SUFFIX}"
        else
          # Production: v1.0.0
          DOCKER_VERSION="v${BASE_VERSION}"
        fi
        
        # Set outputs for workflow use
        echo "version=${DOCKER_VERSION}" >> $GITHUB_OUTPUT
        echo "base_version=${BASE_VERSION}" >> $GITHUB_OUTPUT
        echo "version_suffix=${VERSION_SUFFIX}" >> $GITHUB_OUTPUT
        echo "env_suffix=${ENV_SUFFIX}" >> $GITHUB_OUTPUT
        echo "version_type=${VERSION_TYPE}" >> $GITHUB_OUTPUT
        echo "commit_sha=${COMMIT_SHA}" >> $GITHUB_OUTPUT
        echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
        
        # Log version information
        echo "Generated clean version: ${DOCKER_VERSION}"
        echo "Base version: ${BASE_VERSION}"
        echo "Pre-release suffix: ${VERSION_SUFFIX}"
        echo "Environment: ${ENV_SUFFIX}"
        echo "Version type: ${VERSION_TYPE}"
        echo "Commit SHA: ${COMMIT_SHA}"
        echo "Build date: ${BUILD_DATE}"
